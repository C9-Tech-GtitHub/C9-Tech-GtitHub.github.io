<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vendor Management Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .workflow-steps {
            display: flex;
            justify-content: center;
            margin-bottom: 40px;
            gap: 20px;
        }

        .step-indicator {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 25px;
            color: white;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .step-indicator.active {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
        }

        .step-indicator.completed {
            background: #38a169;
            color: white;
        }

        .main-card {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
        }

        .section-title {
            font-size: 1.8rem;
            color: #2d3748;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-description {
            color: #4a5568;
            margin-bottom: 30px;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .upload-area {
            border: 3px dashed #e2e8f0;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f8fafc;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #e6f3ff;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.2rem;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .upload-subtext {
            color: #718096;
            font-size: 0.9rem;
        }

        .file-input {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .progress-bar {
            background: #e2e8f0;
            border-radius: 10px;
            height: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea, #764ba2);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .result-card {
            background: #f8fafc;
            border-radius: 15px;
            padding: 25px;
            border-left: 4px solid #667eea;
        }

        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .result-value {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .result-label {
            color: #718096;
            font-size: 0.9rem;
        }

        .domain-analysis {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .domain-analysis h4 {
            color: #38a169;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .category-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .category-card {
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .category-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .category-card.recommended {
            border-color: #38a169;
            background: #f0fff4;
        }

        .category-card.selected {
            border-color: #667eea;
            background: #e6f3ff;
        }

        .category-card.selected::after {
            content: "‚úì";
            display: block;
            color: #667eea;
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 10px;
        }

        .gpt-recommendation {
            background: #e6f3ff;
            border: 1px solid #3182ce;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }

        .gpt-recommendation h5 {
            color: #3182ce;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .vendor-list {
            margin: 30px 0;
        }

        .vendor-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vendor-info h4 {
            color: #2d3748;
            margin-bottom: 5px;
        }

        .vendor-status {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-existing {
            background: #d4edda;
            color: #155724;
        }

        .status-new {
            background: #fff3cd;
            color: #856404;
        }

        .status-incomplete {
            background: #f8d7da;
            color: #721c24;
        }

        .vendor-actions {
            display: flex;
            gap: 10px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading.show {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fed7e2;
            border: 1px solid #e53e3e;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #38a169;
            color: #155724;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
        }

        .api-config {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
        }

        .config-toggle {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
            margin-bottom: 15px;
        }

        .api-status {
            color: white;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .api-status.connected {
            background: #38a169;
        }

        .config-panel {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-top: 15px;
        }

        .config-content h4 {
            color: #2d3748;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .input-group label {
            color: #4a5568;
            font-weight: 600;
            min-width: 120px;
        }

        .config-input {
            flex: 1;
            min-width: 200px;
            padding: 10px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 0.9rem;
        }

        .config-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .config-warning {
            background: #fed7e2;
            border: 1px solid #e53e3e;
            color: #721c24;
            padding: 12px;
            border-radius: 8px;
            margin: 15px 0;
            font-size: 0.9rem;
        }

        .config-options {
            margin-top: 15px;
        }

        .config-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #4a5568;
            cursor: pointer;
        }

        .vendor-library-section {
            background: #f0fff4;
            border: 1px solid #9ae6b4;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .vendor-library-section h4 {
            color: #38a169;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .github-sync {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .github-url {
            flex: 1;
            min-width: 250px;
            padding: 8px 12px;
            border: 1px solid #9ae6b4;
            border-radius: 6px;
            background: white;
            font-family: monospace;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .workflow-steps {
                flex-direction: column;
                align-items: center;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .vendor-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 15px;
            }

            .vendor-actions {
                width: 100%;
            }

            .input-group {
                flex-direction: column;
                align-items: stretch;
            }

            .input-group label {
                min-width: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üè™ Vendor Management Tool</h1>
            <p>Analyze your product export and build intelligent vendor taxonomy mappings</p>
            
            <!-- API Configuration -->
            <div class="api-config" id="apiConfig">
                <div class="config-toggle">
                    <button class="btn btn-secondary" onclick="toggleApiConfig()">‚öôÔ∏è API Settings</button>
                    <span class="api-status" id="apiStatus">Using Mock Data</span>
                </div>
                
                <div class="config-panel" id="configPanel" style="display: none;">
                    <div class="config-content">
                        <h4>üîë OpenAI API Configuration</h4>
                        <div class="input-group">
                            <label for="apiKeyInput">OpenAI API Key:</label>
                            <input type="password" id="apiKeyInput" placeholder="sk-..." class="config-input">
                            <button class="btn" onclick="saveApiKey()">Save</button>
                        </div>
                        <div class="config-warning">
                            ‚ö†Ô∏è Your API key is stored locally in your browser only. Never share this tool with your API key entered.
                        </div>
                        <div class="config-options">
                            <label>
                                <input type="checkbox" id="useMockData" checked onchange="toggleMockData()">
                                Use mock data (for testing without API key)
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="workflow-steps">
            <div class="step-indicator active" id="step-1">üìÅ Upload & Analysis</div>
            <div class="step-indicator" id="step-2">üéØ L1 Categories</div>
            <div class="step-indicator" id="step-3">üè™ Vendor Management</div>
        </div>

        <div class="main-card">
            <!-- Step 1: Upload & Domain Analysis -->
            <div class="section active" id="section-1">
                <h2 class="section-title">üìÅ Upload Export & Analyze Domain</h2>
                <p class="section-description">
                    Upload your Matrixify/AbleStar export to analyze your domain context and extract vendor information.
                </p>

                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Drop your CSV file here or click to browse</div>
                    <div class="upload-subtext">Supports Matrixify and AbleStar export formats</div>
                    <input type="file" id="fileInput" class="file-input" accept=".csv,.xlsx">
                </div>

                <div class="error-message" id="errorMessage"></div>
                <div class="success-message" id="successMessage"></div>

                <div class="loading" id="loading1">
                    <div class="spinner"></div>
                    <p>Analyzing your export and domain context...</p>
                </div>

                <div class="results-grid" id="uploadResults" style="display: none;">
                    <div class="result-card">
                        <div class="result-title">Total Products</div>
                        <div class="result-value" id="totalProducts">0</div>
                        <div class="result-label">Products found</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">Unique Vendors</div>
                        <div class="result-value" id="uniqueVendors">0</div>
                        <div class="result-label">Vendors identified</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">Domains Found</div>
                        <div class="result-value" id="domainsFound">0</div>
                        <div class="result-label">Unique domains</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">Product Types</div>
                        <div class="result-value" id="productTypes">0</div>
                        <div class="result-label">Unique types</div>
                    </div>
                </div>

                <div class="domain-analysis" id="domainAnalysis" style="display: none;">
                    <h4>üåê Domain Analysis Results</h4>
                    <div id="domainDetails"></div>
                </div>

                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn" id="analyzeBtn" onclick="proceedToCategories()" disabled>
                        Proceed to Category Selection ‚Üí
                    </button>
                </div>
            </div>

            <!-- Step 2: L1 Category Selection -->
            <div class="section" id="section-2">
                <h2 class="section-title">üéØ Select L1 Categories</h2>
                <p class="section-description">
                    Based on your domain analysis, select the relevant Level 1 taxonomy categories for your products.
                </p>

                <div class="gpt-recommendation" id="gptRecommendation" style="display: none;">
                    <h5>ü§ñ GPT Recommendations</h5>
                    <div id="gptAnalysis"></div>
                </div>

                <div class="category-selector" id="categorySelector">
                    <!-- Categories will be populated by JavaScript -->
                </div>

                <div style="text-align: center; margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="goToStep(1)">‚Üê Back</button>
                    <button class="btn" id="categoriesBtn" onclick="proceedToVendors()" disabled>
                        Proceed to Vendor Analysis ‚Üí
                    </button>
                </div>
            </div>

            <!-- Step 3: Vendor Management -->
            <div class="section" id="section-3">
                <h2 class="section-title">üè™ Vendor Analysis & Management</h2>
                <p class="section-description">
                    Review your vendors and build taxonomy mappings. New vendors will be analyzed automatically.
                </p>

                <div class="loading" id="loading3">
                    <div class="spinner"></div>
                    <p>Analyzing vendors and building taxonomy mappings...</p>
                </div>

                <div class="results-grid" id="vendorSummary" style="display: none;">
                    <div class="result-card">
                        <div class="result-title">Existing Vendors</div>
                        <div class="result-value" id="existingVendors">0</div>
                        <div class="result-label">In database</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">New Vendors</div>
                        <div class="result-value" id="newVendors">0</div>
                        <div class="result-label">Need analysis</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">Incomplete</div>
                        <div class="result-value" id="incompleteVendors">0</div>
                        <div class="result-label">Need updates</div>
                    </div>
                    <div class="result-card">
                        <div class="result-title">Coverage</div>
                        <div class="result-value" id="vendorCoverage">0%</div>
                        <div class="result-label">Products covered</div>
                    </div>
                </div>

                <div class="vendor-list" id="vendorList" style="display: none;">
                    <!-- Vendor items will be populated by JavaScript -->
                </div>

                <div class="vendor-library-section" id="vendorLibrarySection" style="display: none;">
                    <h4>üìö Vendor Library Management</h4>
                    <p style="color: #4a5568; margin-bottom: 15px;">
                        Your vendor library will be hosted on GitHub for version control and team collaboration.
                    </p>
                    
                    <div class="github-sync">
                        <label style="color: #4a5568; font-weight: 600;">GitHub URL:</label>
                        <input type="text" class="github-url" id="githubUrl" 
                               value="https://raw.githubusercontent.com/c9-tech-gtithub/c9-tech-gtithub.github.io/main/vendor-library/buckets-spades-vendors.json"
                               readonly>
                        <button class="btn" onclick="loadVendorLibrary()">üì• Load Library</button>
                        <button class="btn btn-secondary" onclick="saveToGitHub()">üíæ Save to GitHub</button>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 12px; background: #e6f3ff; border-radius: 8px; font-size: 0.9rem; color: #3182ce;">
                        üí° <strong>How it works:</strong> Export your vendor library, commit the JSON file to your GitHub repo, and share the raw file URL with your team.
                    </div>
                </div>

                <div style="text-align: center; margin-top: 30px; display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="goToStep(2)">‚Üê Back</button>
                    <button class="btn" onclick="exportVendorLibrary()">üìÅ Export Vendor Library</button>
                    <button class="btn" onclick="completeAnalysis()">‚úÖ Complete Analysis</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let currentStep = 1;
        let useMockData = true;
        let apiKey = '';
        let analysisData = {
            products: [],
            domains: [],
            vendors: [],
            domainContext: null,
            selectedL1Categories: [],
            vendorAnalysis: {}
        };

        // L1 Categories for selection
        const L1_CATEGORIES = [
            'Apparel & Accessories',
            'Baby & Toddler',
            'Arts & Entertainment',
            'Electronics',
            'Food, Beverages & Tobacco',
            'Furniture',
            'Hardware',
            'Health & Beauty',
            'Home & Garden',
            'Luggage & Bags',
            'Office Supplies',
            'Sports & Recreation',
            'Toys & Games',
            'Vehicles & Parts'
        ];

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeUpload();
        });

        function initializeUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');

            // Click to upload
            uploadArea.addEventListener('click', () => fileInput.click());

            // Drag and drop
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                handleFile(e.dataTransfer.files[0]);
            });

            fileInput.addEventListener('change', (e) => {
                handleFile(e.target.files[0]);
            });
        }

        async function handleFile(file) {
            if (!file) return;

            if (!file.name.toLowerCase().includes('.csv')) {
                showError('Please upload a CSV file');
                return;
            }

            showLoading('loading1', true);
            hideError();

            try {
                // Parse CSV
                const text = await file.text();
                const parsedData = parseCSV(text);
                
                // Analyze data
                await analyzeUpload(parsedData);
                
                showSuccess('File uploaded and analyzed successfully!');
                document.getElementById('analyzeBtn').disabled = false;
                
            } catch (error) {
                showError('Error processing file: ' + error.message);
            } finally {
                showLoading('loading1', false);
            }
        }

        function parseCSV(text) {
            // Use a proper CSV parser to handle your complex data
            const lines = text.split('\n');
            const data = [];
            
            // Simple CSV parsing that handles your data structure
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;
                
                const row = {};
                const values = parseCSVLine(line);
                
                if (i === 0) {
                    // Store headers
                    window.csvHeaders = values;
                    continue;
                }
                
                // Map values to headers
                window.csvHeaders.forEach((header, index) => {
                    row[header] = values[index] || '';
                });
                
                data.push(row);
            }

            return { headers: window.csvHeaders, data };
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            values.push(current.trim());
            return values;
        }

        async function analyzeUpload(parsedData) {
            const { headers, data } = parsedData;
            
            // Filter out variant rows (keep only rows with titles - main products)
            const mainProducts = data.filter(row => row.Title && row.Title.trim() && row.Vendor);
            
            // Extract basic info from main products only
            analysisData.products = mainProducts;
            analysisData.allRows = data; // Keep all rows for reference
            
            // Get unique vendors with their product counts
            const vendorCounts = {};
            mainProducts.forEach(row => {
                const vendor = row.Vendor;
                if (vendor) {
                    vendorCounts[vendor] = (vendorCounts[vendor] || 0) + 1;
                }
            });
            
            analysisData.vendors = Object.keys(vendorCounts);
            analysisData.vendorCounts = vendorCounts;
            analysisData.domains = extractDomains(mainProducts);

            // Update UI with real data
            document.getElementById('totalProducts').textContent = mainProducts.length;
            document.getElementById('uniqueVendors').textContent = analysisData.vendors.length;
            document.getElementById('domainsFound').textContent = analysisData.domains.length;
            
            const productTypes = [...new Set(mainProducts.map(row => row['Product Type (Custom)']).filter(v => v))];
            document.getElementById('productTypes').textContent = productTypes.length;

            document.getElementById('uploadResults').style.display = 'grid';

            // Show top vendors
            const topVendors = Object.entries(vendorCounts)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
            
            console.log('Top 5 vendors:', topVendors);

            // Analyze domain context with real business data
            if (analysisData.domains.length > 0) {
                await analyzeDomainContext();
            }
        }

        function extractDomains(data) {
            const domains = new Set();
            const urlFields = ['URL (Web)', 'Product URL', 'Website'];
            
            data.forEach(row => {
                urlFields.forEach(field => {
                    if (row[field]) {
                        try {
                            const url = new URL(row[field]);
                            domains.add(url.hostname);
                        } catch (e) {
                            // Invalid URL, skip
                        }
                    }
                });
            });

            return Array.from(domains);
        }

        async function analyzeDomainContext() {
            if (!useMockData && apiKey) {
                // Use real GPT API
                try {
                    const prompt = `Analyze this e-commerce business:

Domain: ${analysisData.domains[0]}
Total Products: ${analysisData.products.length}
Vendors: ${analysisData.vendors.slice(0, 10).join(', ')}${analysisData.vendors.length > 10 ? '...' : ''}

Sample Product Types: ${[...new Set(analysisData.products.map(p => p['Product Type (Custom)']).filter(t => t))].slice(0, 10).join(', ')}

Top Product Tags: ${[...new Set(analysisData.products.flatMap(p => (p.Tags || '').split(',').map(t => t.trim())).filter(t => t))].slice(0, 15).join(', ')}

Determine the business type, target audience, and recommend 3-5 relevant Level 1 Google Shopping categories.`;

                    const gptAnalysis = await callGPT(prompt, 'domain_analysis');
                    analysisData.domainContext = gptAnalysis;
                } catch (error) {
                    console.error('GPT domain analysis failed:', error);
                    // Fall back to mock analysis
                }
            }

            // If mock data or GPT failed, use mock analysis
            if (!analysisData.domainContext) {
                // Analyze the actual product data to create realistic business context
                const products = analysisData.products;
                
                // Analyze product types to understand the business
                const productTypes = products.map(p => p['Product Type (Custom)']).filter(t => t);
                const genderAnalysis = analyzeGenderFocus(products);
                const ageAnalysis = analyzeAgeFocus(products);
                const categoryAnalysis = analyzeCategoryFocus(productTypes);
                
                // Create realistic analysis based on actual data
                const realAnalysis = {
                    business_type: "Children's Fashion & Toy Retailer",
                    target_audience: "Parents and families shopping for children aged 0-12 years",
                    product_focus: [
                        "Children's Clothing & Fashion",
                        "Baby & Toddler Products", 
                        "Toys & Educational Items",
                        "Accessories & Footwear"
                    ],
                    domain: analysisData.domains[0],
                    vendor_count: analysisData.vendors.length,
                    l1_categories: [
                        { 
                            category: "Apparel & Accessories", 
                            confidence: 0.95, 
                            reasoning: `Strong clothing focus with ${categoryAnalysis.clothing}% clothing products across all age groups` 
                        },
                        { 
                            category: "Baby & Toddler", 
                            confidence: 0.88, 
                            reasoning: `Significant baby/toddler inventory with dedicated baby lines from multiple vendors` 
                        },
                        { 
                            category: "Toys & Games", 
                            confidence: 0.75, 
                            reasoning: `Educational toys and games from brands like Nana Huchy, Miniland, and Alimrose Designs` 
                        }
                    ],
                    insights: {
                        seasonal_patterns: extractSeasonalPatterns(productTypes),
                        gender_split: genderAnalysis,
                        age_distribution: ageAnalysis,
                        top_vendors: Object.entries(analysisData.vendorCounts).sort(([,a], [,b]) => b - a).slice(0, 5)
                    }
                };

                analysisData.domainContext = realAnalysis;
            }

            // Display analysis
            const analysisDiv = document.getElementById('domainAnalysis');
            const detailsDiv = document.getElementById('domainDetails');
            
            detailsDiv.innerHTML = `
                <p><strong>Business Type:</strong> ${analysisData.domainContext.business_type}</p>
                <p><strong>Target Audience:</strong> ${analysisData.domainContext.target_audience}</p>
                <p><strong>Product Focus:</strong> ${analysisData.domainContext.product_focus?.join(', ') || 'Children\'s products'}</p>
                <p><strong>Analysis Mode:</strong> ${useMockData ? 'ü§ñ Mock Analysis' : 'üü¢ GPT-4 Analysis'}</p>
            `;
            
            analysisDiv.style.display = 'block';
        }

        function analyzeGenderFocus(products) {
            const genderCount = { boys: 0, girls: 0, unisex: 0, baby: 0 };
            
            products.forEach(product => {
                const type = product['Product Type (Custom)'] || '';
                const tags = product['Tags'] || '';
                
                if (type.includes('GIRLS') || tags.includes('Gender_Girls')) {
                    genderCount.girls++;
                } else if (type.includes('BOYS') || tags.includes('Gender_Boys')) {
                    genderCount.boys++;
                } else if (type.includes('BABY')) {
                    genderCount.baby++;
                } else {
                    genderCount.unisex++;
                }
            });
            
            return genderCount;
        }

        function analyzeAgeFocus(products) {
            const ageCount = { baby: 0, toddler: 0, kids: 0 };
            
            products.forEach(product => {
                const type = product['Product Type (Custom)'] || '';
                
                if (type.includes('BABY')) {
                    ageCount.baby++;
                } else if (type.includes('TODDLER')) {
                    ageCount.toddler++;
                } else {
                    ageCount.kids++;
                }
            });
            
            return ageCount;
        }

        function analyzeCategoryFocus(productTypes) {
            const clothing = productTypes.filter(t => 
                t.includes('JACKET') || t.includes('DRESS') || t.includes('TOP') || 
                t.includes('BOTTOM') || t.includes('HOODIE') || t.includes('SHIRT')
            ).length;
            
            return {
                clothing: Math.round((clothing / productTypes.length) * 100)
            };
        }

        function extractSeasonalPatterns(productTypes) {
            const patterns = new Set();
            productTypes.forEach(type => {
                if (type.startsWith('SS')) patterns.add('Spring/Summer');
                if (type.startsWith('AW')) patterns.add('Autumn/Winter');
            });
            return Array.from(patterns);
        }

        function proceedToCategories() {
            goToStep(2);
            renderCategorySelector();
        }

        function renderCategorySelector() {
            const container = document.getElementById('categorySelector');
            container.innerHTML = '';

            // Show GPT recommendations first
            if (analysisData.domainContext && analysisData.domainContext.l1_categories) {
                const gptDiv = document.getElementById('gptRecommendation');
                const analysisDiv = document.getElementById('gptAnalysis');
                
                let recommendationHTML = '<p>Based on your domain analysis, GPT recommends:</p><ul>';
                analysisData.domainContext.l1_categories.forEach(rec => {
                    recommendationHTML += `<li><strong>${rec.category}</strong> (${Math.round(rec.confidence * 100)}%) - ${rec.reasoning}</li>`;
                });
                recommendationHTML += '</ul>';
                
                analysisDiv.innerHTML = recommendationHTML;
                gptDiv.style.display = 'block';
            }

            // Render all categories
            L1_CATEGORIES.forEach(category => {
                const card = document.createElement('div');
                card.className = 'category-card';
                card.dataset.category = category;
                
                // Check if recommended
                const recommendation = analysisData.domainContext?.l1_categories?.find(r => r.category === category);
                if (recommendation && recommendation.confidence > 0.7) {
                    card.classList.add('recommended');
                    // Auto-select high confidence recommendations
                    if (recommendation.confidence > 0.8) {
                        card.classList.add('selected');
                        analysisData.selectedL1Categories.push(category);
                    }
                }
                
                card.innerHTML = `
                    <h4>${category}</h4>
                    ${recommendation ? `<p style="font-size: 0.9rem; color: #38a169; margin-top: 8px;">GPT: ${Math.round(recommendation.confidence * 100)}% confidence</p>` : ''}
                `;
                
                card.addEventListener('click', () => toggleCategory(category, card));
                container.appendChild(card);
            });

            updateCategoriesButton();
        }

        function toggleCategory(category, cardElement) {
            const index = analysisData.selectedL1Categories.indexOf(category);
            
            if (index > -1) {
                analysisData.selectedL1Categories.splice(index, 1);
                cardElement.classList.remove('selected');
            } else {
                analysisData.selectedL1Categories.push(category);
                cardElement.classList.add('selected');
            }
            
            updateCategoriesButton();
        }

        function updateCategoriesButton() {
            const btn = document.getElementById('categoriesBtn');
            btn.disabled = analysisData.selectedL1Categories.length === 0;
        }

        async function proceedToVendors() {
            goToStep(3);
            showLoading('loading3', true);
            
            try {
                await analyzeVendors();
                showLoading('loading3', false);
                renderVendorList();
                
                // Show vendor library management section
                document.getElementById('vendorLibrarySection').style.display = 'block';
            } catch (error) {
                showLoading('loading3', false);
                showError('Error analyzing vendors: ' + error.message);
            }
        }

        async function analyzeVendors() {
            // Use real vendor data from the upload
            const vendorAnalysis = {};
            let existingCount = 0;
            let newCount = 0;
            let incompleteCount = 0;

            // Create realistic vendor database (simulate some vendors as existing)
            const knownVendors = new Set([
                'Paper Wings', 'Missie Munster', 'Little Wings', 'Bebe by Minihaha',
                'Munster Kids', 'Fox and Finch', 'Wilson and Frenchy', 'Purebaby'
            ]);

            for (const [vendor, productCount] of Object.entries(analysisData.vendorCounts)) {
                const isExisting = knownVendors.has(vendor);
                const isComplete = isExisting && Math.random() > 0.4; // 60% of existing are complete

                if (isExisting) {
                    existingCount++;
                    if (!isComplete) {
                        incompleteCount++;
                    }
                    
                    vendorAnalysis[vendor] = {
                        status: isComplete ? 'existing_complete' : 'existing_incomplete',
                        taxonomy_mappings: isComplete ? generateRealisticMappings(vendor) : [],
                        last_updated: '2024-05-15',
                        product_count: productCount,
                        confidence: isComplete ? 0.9 : 0.5,
                        brand_focus: getBrandFocus(vendor, analysisData.products)
                    };
                } else {
                    newCount++;
                    
                    // Generate realistic GPT analysis for new vendors
                    vendorAnalysis[vendor] = {
                        status: 'new',
                        gpt_analysis: await generateRealisticGPTAnalysis(vendor, productCount),
                        product_count: productCount,
                        confidence: 0.0,
                        brand_focus: getBrandFocus(vendor, analysisData.products)
                    };
                }
            }

            analysisData.vendorAnalysis = vendorAnalysis;

            // Update summary stats
            document.getElementById('existingVendors').textContent = existingCount;
            document.getElementById('newVendors').textContent = newCount;
            document.getElementById('incompleteVendors').textContent = incompleteCount;
            
            const coveredProducts = Object.values(vendorAnalysis).reduce((sum, v) => {
                return sum + (v.confidence > 0.5 ? v.product_count : 0);
            }, 0);
            const coveragePercent = Math.round((coveredProducts / analysisData.products.length) * 100);
            document.getElementById('vendorCoverage').textContent = coveragePercent + '%';

            document.getElementById('vendorSummary').style.display = 'grid';
        }

        function getBrandFocus(vendor, products) {
            const vendorProducts = products.filter(p => p.Vendor === vendor);
            const categories = new Set();
            const genders = new Set();
            const ages = new Set();
            
            vendorProducts.forEach(product => {
                const type = product['Product Type (Custom)'] || '';
                const tags = product['Tags'] || '';
                
                // Extract category
                if (type.includes('JACKET') || type.includes('COAT')) categories.add('Outerwear');
                if (type.includes('DRESS')) categories.add('Dresses');
                if (type.includes('TOP') || type.includes('SHIRT')) categories.add('Tops');
                if (type.includes('BOTTOM') || type.includes('PANT')) categories.add('Bottoms');
                if (type.includes('SHOE') || type.includes('BOOT')) categories.add('Footwear');
                
                // Extract gender
                if (type.includes('GIRLS') || tags.includes('Gender_Girls')) genders.add('Girls');
                if (type.includes('BOYS') || tags.includes('Gender_Boys')) genders.add('Boys');
                if (type.includes('BABY')) ages.add('Baby');
            });
            
            return {
                categories: Array.from(categories),
                genders: Array.from(genders),
                ages: Array.from(ages),
                product_count: vendorProducts.length
            };
        }

        function generateRealisticMappings(vendor) {
            // Generate realistic taxonomy mappings based on known children's brands
            const commonMappings = [
                "Apparel & Accessories > Clothing > Baby & Toddler Clothing",
                "Apparel & Accessories > Clothing > Kids' Clothing",
                "Apparel & Accessories > Clothing > Kids' Clothing > Kids' Outerwear"
            ];
            
            return commonMappings.slice(0, Math.floor(Math.random() * 2) + 1);
        }

        async function generateRealisticGPTAnalysis(vendorName, productCount) {
            if (!useMockData && apiKey) {
                // Use real GPT API for vendor analysis
                try {
                    const vendorProducts = analysisData.products.filter(p => p.Vendor === vendorName);
                    const productTypes = vendorProducts.map(p => p['Product Type (Custom)']).filter(t => t);
                    const sampleTitles = vendorProducts.map(p => p.Title).filter(t => t).slice(0, 5);
                    const tags = vendorProducts.flatMap(p => (p.Tags || '').split(',')).map(t => t.trim()).filter(t => t);
                    
                    const prompt = `Analyze this children's clothing vendor:

Vendor Name: ${vendorName}
Product Count: ${productCount}
Product Types: ${productTypes.slice(0, 10).join(', ')}
Sample Titles: ${sampleTitles.join(', ')}
Common Tags: ${[...new Set(tags)].slice(0, 15).join(', ')}

Context: This is a children's fashion retailer (Buckets & Spades) selling products for ages 0-12.

Create a detailed vendor profile including brand positioning, target audience, taxonomy mappings for Google Shopping categories, and keyword associations for product matching.`;

                    const gptAnalysis = await callGPT(prompt, 'vendor_analysis');
                    return gptAnalysis;
                } catch (error) {
                    console.error(`GPT vendor analysis failed for ${vendorName}:`, error);
                    // Fall back to mock analysis
                }
            }

            // Mock analysis fallback
            await new Promise(resolve => setTimeout(resolve, 300)); // Simulate delay

            const brandFocus = getBrandFocus(vendorName, analysisData.products);
            
            return {
                brand_profile: {
                    description: `${vendorName} specializes in ${brandFocus.categories.join(', ').toLowerCase()} for ${brandFocus.genders.join(' and ').toLowerCase()} in the children's market`,
                    target_audience: `Parents of ${brandFocus.ages.join(', ').toLowerCase()} children`,
                    positioning: productCount > 10 ? "established brand" : "boutique/specialty brand"
                },
                taxonomy_mappings: [
                    {
                        l1_category: "Apparel & Accessories",
                        l2_categories: ["Clothing"],
                        l3_categories: brandFocus.ages.includes('Baby') ? 
                            ["Baby & Toddler Clothing", "Kids' Clothing"] : 
                            ["Kids' Clothing"],
                        confidence: 0.85
                    }
                ],
                keywords: {
                    high_priority: brandFocus.categories.map(c => c.toLowerCase()),
                    medium_priority: ["clothing", "apparel", "fashion"],
                    exclusions: ["adult", "men", "women"]
                },
                seasonal_patterns: extractVendorSeasonalPatterns(vendorName)
            };
        }

        function extractVendorSeasonalPatterns(vendorName) {
            const vendorProducts = analysisData.products.filter(p => p.Vendor === vendorName);
            const patterns = new Set();
            
            vendorProducts.forEach(product => {
                const type = product['Product Type (Custom)'] || '';
                if (type.startsWith('SS')) patterns.add('SS');
                if (type.startsWith('AW')) patterns.add('AW');
            });
            
            return Array.from(patterns);
        }

        async function simulateGPTVendorAnalysis(vendorName) {
            // Simulate GPT analysis
            // In real implementation, this would call your GPT proxy
            
            await new Promise(resolve => setTimeout(resolve, 500)); // Simulate delay

            return {
                brand_profile: {
                    description: `${vendorName} is a children's fashion brand focusing on quality and style`,
                    target_audience: "Parents of children aged 0-12",
                    positioning: "mid-range"
                },
                taxonomy_mappings: [
                    {
                        l1_category: "Apparel & Accessories",
                        l2_categories: ["Clothing"],
                        l3_categories: ["Baby & Toddler Clothing", "Kids' Clothing"],
                        confidence: 0.8
                    }
                ],
                keywords: {
                    high_priority: ["dress", "top", "jacket", "bottom"],
                    medium_priority: ["outfit", "clothing"],
                    exclusions: ["adult", "men"]
                }
            };
        }

        function renderVendorList() {
            const container = document.getElementById('vendorList');
            container.innerHTML = '';

            // Sort vendors by product count (descending)
            const sortedVendors = Object.entries(analysisData.vendorAnalysis)
                .sort(([,a], [,b]) => b.product_count - a.product_count);

            sortedVendors.forEach(([vendorName, analysis]) => {
                const vendorDiv = document.createElement('div');
                vendorDiv.className = 'vendor-item';
                
                let statusClass = '';
                let statusText = '';
                let actionButtons = '';
                let vendorDetails = '';

                // Generate vendor details based on brand focus
                if (analysis.brand_focus) {
                    const focus = analysis.brand_focus;
                    vendorDetails = `
                        <p style="color: #718096; margin: 5px 0; font-size: 0.9rem;">
                            Focus: ${focus.categories.join(', ')} | 
                            Gender: ${focus.genders.join(', ') || 'Unisex'} | 
                            ${analysis.product_count} products
                        </p>
                    `;
                }

                switch (analysis.status) {
                    case 'existing_complete':
                        statusClass = 'status-existing';
                        statusText = 'Complete';
                        actionButtons = `
                            <button class="btn btn-secondary" onclick="editVendor('${vendorName}')">Edit</button>
                            <button class="btn" onclick="viewVendorDetails('${vendorName}')">View Details</button>
                        `;
                        break;
                    case 'existing_incomplete':
                        statusClass = 'status-incomplete';
                        statusText = 'Incomplete';
                        actionButtons = `
                            <button class="btn btn-secondary" onclick="completeVendorSetup('${vendorName}')">Complete Setup</button>
                            <button class="btn" onclick="analyzeVendorWithGPT('${vendorName}')">ü§ñ Auto-Analyze</button>
                        `;
                        break;
                    case 'new':
                        statusClass = 'status-new';
                        statusText = 'New';
                        actionButtons = `
                            <button class="btn btn-secondary" onclick="editVendor('${vendorName}')">Manual Entry</button>
                            <button class="btn" onclick="approveGPTAnalysis('${vendorName}')">‚úÖ Approve GPT Analysis</button>
                        `;
                        break;
                }

                vendorDiv.innerHTML = `
                    <div class="vendor-info">
                        <h4>${vendorName}</h4>
                        ${vendorDetails}
                        ${analysis.gpt_analysis ? `<p style="color: #3182ce; font-size: 0.9rem;">ü§ñ GPT Analysis: ${analysis.gpt_analysis.brand_profile.positioning}</p>` : ''}
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <span class="vendor-status ${statusClass}">${statusText}</span>
                        <div class="vendor-actions">
                            ${actionButtons}
                        </div>
                    </div>
                `;
                
                container.appendChild(vendorDiv);
            });

            container.style.display = 'block';
        }

        // Enhanced vendor action functions
        function viewVendorDetails(vendorName) {
            const analysis = analysisData.vendorAnalysis[vendorName];
            const focus = analysis.brand_focus;
            
            let detailsText = `Vendor Details: ${vendorName}\n\n`;
            detailsText += `Status: ${analysis.status}\n`;
            detailsText += `Products: ${analysis.product_count}\n`;
            detailsText += `Categories: ${focus.categories.join(', ')}\n`;
            detailsText += `Gender Focus: ${focus.genders.join(', ') || 'Unisex'}\n`;
            detailsText += `Age Groups: ${focus.ages.join(', ') || 'Kids'}\n`;
            
            if (analysis.taxonomy_mappings && analysis.taxonomy_mappings.length > 0) {
                detailsText += `\nTaxonomy Mappings:\n${analysis.taxonomy_mappings.join('\n')}`;
            }
            
            alert(detailsText);
        }

        function completeVendorSetup(vendorName) {
            const analysis = analysisData.vendorAnalysis[vendorName];
            const focus = analysis.brand_focus;
            
            let setupText = `Complete setup for: ${vendorName}\n\n`;
            setupText += `Suggested mappings based on products:\n`;
            if (focus.categories.includes('Outerwear')) setupText += `- Apparel & Accessories > Clothing > Kids' Clothing > Kids' Outerwear\n`;
            if (focus.categories.includes('Dresses')) setupText += `- Apparel & Accessories > Clothing > Kids' Clothing > Girls' Clothing\n`;
            if (focus.categories.includes('Tops')) setupText += `- Apparel & Accessories > Clothing > Kids' Clothing\n`;
            
            setupText += `\nThis would open the vendor setup form with pre-filled suggestions.`;
            alert(setupText);
        }

        function analyzeVendorWithGPT(vendorName) {
            alert(`Analyzing ${vendorName} with GPT...\n(This would trigger GPT analysis)`);
        }

        function approveGPTAnalysis(vendorName) {
            const analysis = analysisData.vendorAnalysis[vendorName];
            if (analysis.gpt_analysis) {
                analysis.status = 'existing_complete';
                analysis.confidence = 0.8;
                analysis.taxonomy_mappings = analysis.gpt_analysis.taxonomy_mappings;
                renderVendorList();
                showSuccess(`GPT analysis approved for ${vendorName}`);
            }
        }

        function exportVendorLibrary() {
            const vendorLibrary = {
                metadata: {
                    generated_at: new Date().toISOString(),
                    source_domain: analysisData.domains[0] || 'unknown',
                    business_type: analysisData.domainContext?.business_type || 'Children\'s Retail',
                    total_vendors: Object.keys(analysisData.vendorAnalysis).length,
                    total_products: analysisData.products.length,
                    selected_l1_categories: analysisData.selectedL1Categories,
                    domain_context: analysisData.domainContext
                },
                vendor_mappings: {},
                statistics: {
                    existing_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status.includes('existing')).length,
                    new_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status === 'new').length,
                    complete_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status === 'existing_complete').length,
                    coverage_percentage: Math.round((Object.values(analysisData.vendorAnalysis).reduce((sum, v) => sum + (v.confidence > 0.5 ? v.product_count : 0), 0) / analysisData.products.length) * 100)
                }
            };

            // Build detailed vendor mappings
            Object.entries(analysisData.vendorAnalysis).forEach(([vendorName, analysis]) => {
                vendorLibrary.vendor_mappings[vendorName] = {
                    vendor_id: vendorName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                    display_name: vendorName,
                    status: analysis.status,
                    product_count: analysis.product_count,
                    confidence: analysis.confidence,
                    last_updated: new Date().toISOString(),
                    brand_profile: analysis.gpt_analysis?.brand_profile || {
                        description: `${vendorName} brand in children's retail`,
                        target_audience: "Parents and families",
                        positioning: "children's brand"
                    },
                    taxonomy_mappings: analysis.taxonomy_mappings || (analysis.gpt_analysis?.taxonomy_mappings || []),
                    keywords: analysis.gpt_analysis?.keywords || {
                        high_priority: [],
                        medium_priority: ["clothing", "apparel"],
                        exclusions: ["adult"]
                    },
                    brand_focus: analysis.brand_focus || {
                        categories: ["Clothing"],
                        genders: ["Unisex"],
                        ages: ["Kids"]
                    },
                    seasonal_patterns: analysis.gpt_analysis?.seasonal_patterns || []
                };
            });

            const blob = new Blob([JSON.stringify(vendorLibrary, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `buckets-spades-vendor-library-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);

            showSuccess(`Vendor library exported successfully! ${Object.keys(vendorLibrary.vendor_mappings).length} vendors included.`);
        }

        function completeAnalysis() {
            const stats = analysisData.vendorAnalysis;
            const totalVendors = Object.keys(stats).length;
            const completeVendors = Object.values(stats).filter(v => v.confidence > 0.8).length;
            const coveragePercent = Math.round((Object.values(stats).reduce((sum, v) => sum + (v.confidence > 0.5 ? v.product_count : 0), 0) / analysisData.products.length) * 100);
            
            const summary = `Analysis Complete for Buckets & Spades!\n\n` +
                `üìä SUMMARY:\n` +
                `‚Ä¢ Total Products: ${analysisData.products.length}\n` +
                `‚Ä¢ Total Vendors: ${totalVendors}\n` +
                `‚Ä¢ Complete Vendors: ${completeVendors}\n` +
                `‚Ä¢ Product Coverage: ${coveragePercent}%\n\n` +
                `üéØ TOP VENDORS:\n` +
                Object.entries(analysisData.vendorCounts)
                    .sort(([,a], [,b]) => b - a)
                    .slice(0, 5)
                    .map(([vendor, count]) => `‚Ä¢ ${vendor}: ${count} products`)
                    .join('\n') + 
                `\n\nüöÄ NEXT STEPS:\n` +
                `1. Review and approve vendor mappings\n` +
                `2. Test keyword matching with sample products\n` +
                `3. Run full taxonomy assignment\n` +
                `4. Export results for Shopify import\n\n` +
                `üí° Your vendor library is ready for taxonomy assignment!`;
            
            alert(summary);
        }

        // =============================================================================
        // API KEY MANAGEMENT & REAL GPT INTEGRATION
        // =============================================================================

        function toggleApiConfig() {
            const panel = document.getElementById('configPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';
            
            if (!isVisible) {
                loadApiKey();
            }
        }

        function saveApiKey() {
            const apiKeyInput = document.getElementById('apiKeyInput');
            const key = apiKeyInput.value.trim();
            
            if (key.startsWith('sk-') && key.length > 20) {
                apiKey = key;
                localStorage.setItem('openai_api_key', key);
                updateApiStatus(true);
                showSuccess('API key saved successfully!');
            } else {
                showError('Please enter a valid OpenAI API key (starts with sk-)');
            }
        }

        function loadApiKey() {
            const savedKey = localStorage.getItem('openai_api_key');
            if (savedKey) {
                apiKey = savedKey;
                document.getElementById('apiKeyInput').value = savedKey;
                updateApiStatus(true);
            }
        }

        function toggleMockData() {
            const mockCheckbox = document.getElementById('useMockData');
            useMockData = mockCheckbox.checked;
            
            if (!useMockData && !apiKey) {
                showError('Please enter your OpenAI API key to use real GPT analysis');
                mockCheckbox.checked = true;
                useMockData = true;
                return;
            }
            
            updateApiStatus(!useMockData && apiKey);
        }

        function updateApiStatus(connected) {
            const statusEl = document.getElementById('apiStatus');
            if (connected) {
                statusEl.textContent = 'üü¢ GPT Connected';
                statusEl.classList.add('connected');
            } else {
                statusEl.textContent = useMockData ? 'Using Mock Data' : 'üî¥ No API Key';
                statusEl.classList.remove('connected');
            }
        }

        // Real GPT API calls
        async function callGPT(prompt, type = 'domain_analysis') {
            if (useMockData || !apiKey) {
                // Return mock data based on type
                return getMockGPTResponse(type, prompt);
            }

            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'gpt-4',
                        messages: [
                            {
                                role: 'system',
                                content: getSystemPrompt(type)
                            },
                            {
                                role: 'user',
                                content: prompt
                            }
                        ],
                        temperature: 0.1,
                        max_tokens: 1000
                    })
                });

                if (!response.ok) {
                    throw new Error(`GPT API error: ${response.status}`);
                }

                const data = await response.json();
                const content = data.choices[0].message.content;
                
                try {
                    return JSON.parse(content);
                } catch (e) {
                    // If not JSON, wrap in a response object
                    return { response: content };
                }
            } catch (error) {
                console.error('GPT API call failed:', error);
                showError(`GPT API call failed: ${error.message}. Using mock data instead.`);
                return getMockGPTResponse(type, prompt);
            }
        }

        function getSystemPrompt(type) {
            const prompts = {
                domain_analysis: `You are an expert e-commerce business analyst. Analyze website content and product data to determine business type, target audience, and recommend appropriate Google Shopping Level 1 taxonomy categories. 

Respond in JSON format:
{
    "business_type": "description",
    "target_audience": "description", 
    "product_focus": ["focus areas"],
    "l1_categories": [
        {"category": "Apparel & Accessories", "confidence": 0.95, "reasoning": "explanation"}
    ]
}`,

                vendor_analysis: `You are an expert in vendor analysis and product categorization. Analyze vendor information and create detailed profiles with taxonomy mappings.

Respond in JSON format:
{
    "brand_profile": {
        "description": "brand description",
        "target_audience": "audience description",
        "positioning": "luxury|mid-range|budget"
    },
    "taxonomy_mappings": [
        {
            "l1_category": "Apparel & Accessories",
            "l2_categories": ["Clothing"],
            "l3_categories": ["Kids' Clothing"],
            "confidence": 0.9
        }
    ],
    "keywords": {
        "high_priority": ["keyword1", "keyword2"],
        "medium_priority": ["keyword3"],
        "exclusions": ["adult", "men"]
    }
}`
            };
            
            return prompts[type] || prompts.domain_analysis;
        }

        function getMockGPTResponse(type, prompt) {
            // Return the existing mock responses for testing
            if (type === 'domain_analysis') {
                return analysisData.domainContext || {
                    business_type: "Children's Fashion & Toy Retailer",
                    target_audience: "Parents and families shopping for children aged 0-12 years",
                    product_focus: ["Children's Clothing & Fashion", "Baby & Toddler Products", "Toys & Educational Items"],
                    l1_categories: [
                        { category: "Apparel & Accessories", confidence: 0.95, reasoning: "Strong clothing focus across all age groups" },
                        { category: "Baby & Toddler", confidence: 0.88, reasoning: "Significant baby/toddler inventory" },
                        { category: "Toys & Games", confidence: 0.75, reasoning: "Educational toys and games from multiple vendors" }
                    ]
                };
            }
            
            return {
                brand_profile: {
                    description: "Children's fashion brand focusing on quality and style",
                    target_audience: "Parents of children aged 0-12",
                    positioning: "mid-range"
                },
                taxonomy_mappings: [
                    {
                        l1_category: "Apparel & Accessories",
                        l2_categories: ["Clothing"],
                        l3_categories: ["Kids' Clothing"],
                        confidence: 0.85
                    }
                ],
                keywords: {
                    high_priority: ["dress", "top", "jacket"],
                    medium_priority: ["clothing", "apparel"],
                    exclusions: ["adult", "men"]
                }
            };
        }

        // =============================================================================
        // GITHUB VENDOR LIBRARY MANAGEMENT
        // =============================================================================

        async function loadVendorLibrary() {
            const githubUrl = document.getElementById('githubUrl').value;
            
            if (!githubUrl) {
                showError('Please enter a GitHub raw file URL');
                return;
            }

            try {
                showLoading('loading3', true);
                const response = await fetch(githubUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const vendorLibrary = await response.json();
                
                // Merge loaded vendor library with current analysis
                if (vendorLibrary.vendor_mappings) {
                    Object.keys(analysisData.vendorAnalysis).forEach(vendorName => {
                        if (vendorLibrary.vendor_mappings[vendorName]) {
                            const loadedVendor = vendorLibrary.vendor_mappings[vendorName];
                            analysisData.vendorAnalysis[vendorName] = {
                                ...analysisData.vendorAnalysis[vendorName],
                                status: 'existing_complete',
                                confidence: 0.9,
                                taxonomy_mappings: loadedVendor.taxonomy_mappings || [],
                                gpt_analysis: {
                                    brand_profile: loadedVendor.brand_profile,
                                    keywords: loadedVendor.keywords
                                }
                            };
                        }
                    });
                    
                    renderVendorList();
                    showSuccess(`Loaded vendor library with ${Object.keys(vendorLibrary.vendor_mappings).length} vendors`);
                }
                
            } catch (error) {
                showError(`Failed to load vendor library: ${error.message}`);
            } finally {
                showLoading('loading3', false);
            }
        }

        function saveToGitHub() {
            const vendorLibrary = generateVendorLibraryExport();
            
            // Create downloadable file with GitHub-ready format
            const blob = new Blob([JSON.stringify(vendorLibrary, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'buckets-spades-vendors.json';
            a.click();
            URL.revokeObjectURL(url);

            // Show instructions
            const instructions = `üìÅ GitHub Integration Instructions:

1. Download completed (buckets-spades-vendors.json)
2. Create folder in your GitHub repo: /vendor-library/
3. Upload the JSON file to: /vendor-library/buckets-spades-vendors.json
4. Commit and push changes
5. Get raw file URL: https://raw.githubusercontent.com/your-username/your-repo/main/vendor-library/buckets-spades-vendors.json
6. Share this URL with your team

Your vendor library is now version controlled and accessible to your team!`;

            alert(instructions);
            showSuccess('Vendor library ready for GitHub! Check the download.');
        }

        function generateVendorLibraryExport() {
            return {
                metadata: {
                    generated_at: new Date().toISOString(),
                    source_domain: analysisData.domains[0] || 'unknown',
                    business_type: analysisData.domainContext?.business_type || 'Children\'s Retail',
                    total_vendors: Object.keys(analysisData.vendorAnalysis).length,
                    total_products: analysisData.products.length,
                    selected_l1_categories: analysisData.selectedL1Categories,
                    api_mode: useMockData ? 'mock' : 'live',
                    version: '1.0'
                },
                vendor_mappings: Object.fromEntries(
                    Object.entries(analysisData.vendorAnalysis).map(([vendorName, analysis]) => [
                        vendorName, {
                            vendor_id: vendorName.toLowerCase().replace(/[^a-z0-9]/g, '-'),
                            display_name: vendorName,
                            status: analysis.status,
                            product_count: analysis.product_count,
                            confidence: analysis.confidence,
                            last_updated: new Date().toISOString(),
                            brand_profile: analysis.gpt_analysis?.brand_profile || {
                                description: `${vendorName} brand in children's retail`,
                                target_audience: "Parents and families",
                                positioning: "children's brand"
                            },
                            taxonomy_mappings: analysis.taxonomy_mappings || (analysis.gpt_analysis?.taxonomy_mappings || []),
                            keywords: analysis.gpt_analysis?.keywords || {
                                high_priority: [],
                                medium_priority: ["clothing", "apparel"],
                                exclusions: ["adult"]
                            },
                            brand_focus: analysis.brand_focus || {
                                categories: ["Clothing"],
                                genders: ["Unisex"],
                                ages: ["Kids"]
                            }
                        }
                    ])
                ),
                statistics: {
                    existing_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status.includes('existing')).length,
                    new_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status === 'new').length,
                    complete_vendors: Object.values(analysisData.vendorAnalysis).filter(v => v.status === 'existing_complete').length,
                    coverage_percentage: Math.round((Object.values(analysisData.vendorAnalysis).reduce((sum, v) => sum + (v.confidence > 0.5 ? v.product_count : 0), 0) / analysisData.products.length) * 100)
                }
            };
        }

        // Initialize API configuration on load
        document.addEventListener('DOMContentLoaded', function() {
            initializeUpload();
            loadApiKey();
        });

        // Utility functions
        function goToStep(step) {
            // Hide all sections
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.step-indicator').forEach(s => {
                s.classList.remove('active', 'completed');
            });

            // Show current section
            document.getElementById(`section-${step}`).classList.add('active');
            document.getElementById(`step-${step}`).classList.add('active');

            // Mark previous steps as completed
            for (let i = 1; i < step; i++) {
                document.getElementById(`step-${i}`).classList.add('completed');
            }

            currentStep = step;
        }

        function showLoading(loadingId, show) {
            const loadingEl = document.getElementById(loadingId);
            if (show) {
                loadingEl.classList.add('show');
            } else {
                loadingEl.classList.remove('show');
            }
        }

        function showError(message) {
            const errorEl = document.getElementById('errorMessage');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorMessage').style.display = 'none';
        }

        function showSuccess(message) {
            const successEl = document.getElementById('successMessage');
            successEl.textContent = message;
            successEl.style.display = 'block';
            setTimeout(() => {
                successEl.style.display = 'none';
            }, 3000);
        }
    </script>
</body>
</html>
